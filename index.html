<!--<!DOCTYPE html>-->
<!--<html>-->
  <!--<head>-->
    <!--<meta charset="utf-8">-->
    <!--<meta name="viewport" content="width=device-width">-->
    <!--<script src="https://d3js.org/d3.v4.min.js"></script>-->
    <!--<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.24.0/d3-legend.min.js"></script>-->
    <!--<title>Visualization Project</title>-->
    <!--<link rel="stylesheet" href="css/styles.css">-->
  <!--</head>-->
  <!--<body>-->
    <!--<div id="visualization">-->
      <!--<svg></svg>-->
    <!--</div>-->
    <!--<script src="./dist/bundle.js"></script>-->
  <!--</body>-->
<!--</html>-->
<!DOCTYPE html>
<meta charset="utf-8">
<title>D3 World Map Template | TechSlides</title>
<style>
  .country:hover {
    stroke: #fff;
    stroke-width: 1.5px;
  }

  .text {
    font-size: 10px;
    text-transform: capitalize;
  }

  #container {
    margin: 10px 5%;
    border: 2px solid #000;
    border-radius: 5px;
    height: 100%;
    overflow: hidden;
    background: #F0F8FF;
  }

  #container2 {
    margin: 10px 5%;
    border: 2px solid #000;
    border-radius: 5px;
    height: 100%;
    overflow: hidden;
    background: #F0F8FF;
  }

  .hidden {
    display: none;
  }

  div.tooltip {
    color: #222;
    background: #fff;
    padding: .5em;
    text-shadow: #f5f5f5 0 1px 0;
    border-radius: 2px;
    box-shadow: 0px 0px 2px 0px #a6a6a6;
    opacity: 0.9;
    position: absolute;
  }

  .graticule {
    fill: none;
    stroke: #bbb;
    stroke-width: .5px;
    stroke-opacity: .5;
  }

  .equator {
    stroke: #ccc;
    stroke-width: 1px;
  }

</style>
</head>
<body>

<div id="container"></div>
<div id="container2"></div>

<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://d3js.org/topojson.v1.min.js"></script>


<script>
    d3.select(window).on("resize", throttle);

    var zoom = d3.zoom()
    //.extent([1,9])
        .scaleExtent([1, 9])
        .on("zoom", move);

    var c = document.getElementById('container');
    var width = c.offsetWidth;
    var height = width / 3 * 2;

    const margin = {left: 30, right: 15, top: 15, bottom: 18};
    const innerWidth = width - margin.left - margin.right;
    const innerHeight = height / 5 - margin.top - margin.bottom;

    //offsets for tooltips
    var offsetL = c.offsetLeft + 20;
    var offsetT = c.offsetTop + 10;

    var topo, projection, path, svg, g;

    //var graticule = d3.geo.graticule();
    var graticule = d3.geoGraticule();

    var tooltip = d3.select("#container").append("div").attr("class", "tooltip hidden");

    const xScale = d3.scaleBand()
            .paddingInner(0.1)
            .paddingOuter(0.1),
        yScale = d3.scaleLinear();

    const xAxis = d3.axisBottom(xScale),
        yAxis = d3.axisLeft(yScale);

    //    var	parseDate = d3.timeFormat("%Y%m%d").parse;

    var brush = d3.brushX()
        .extent([[margin.left, margin.top], [innerWidth + margin.left, innerHeight + margin.top]])
        .on("brush end", brushed);

    setup(width, height);

    function setup(width, height) {
        //projection = d3.geo.mercator()
        projection = d3.geoMercator()
            .translate([(width / 2), (height / 2)])
            .scale(width / 2 / Math.PI);

        //path = d3.geo.path().projection(projection);
        path = d3.geoPath().projection(projection);

        svg = d3.select("#container").append("svg")
            .attr("width", width)
            .attr("height", height)
            .call(zoom)
            //.on("click", click)
            .append("g");

        g = svg.append("g")
            .on("click", click);

        barChart = d3.select("#container2").append("svg")
            .attr('width', width)
            .attr('height', height / 5);

        g2 = barChart.append('g')
            .attr('transform', `translate(${margin.left},${margin.top})`);
    }

    d3.json("data/world-topo-min.json", function (error, world) {

        var countries = topojson.feature(world, world.objects.countries).features;

        topo = countries;
        draw(topo);

    });

    function handleMouseOver() {
        var mouse = d3.mouse(svg.node()).map(function (d) {
            return parseInt(d);
        });

        tooltip.classed("hidden", false)
            .attr("style", "left:" + (mouse[0] + offsetL) + "px;top:" + (mouse[1] + offsetT) + "px")
            .html(this.__data__.properties.name);
    }

    function handleMouseOut() {
        tooltip.classed("hidden", true);
    }


    function draw(topo) {

        svg.append("path")
            .datum(graticule)
            .attr("class", "graticule")
            .attr("d", path);


        g.append("path")
            .datum({type: "LineString", coordinates: [[-180, 0], [-90, 0], [0, 0], [90, 0], [180, 0]]})
            .attr("class", "equator")
            .attr("d", path);


        var country = g.selectAll(".country").data(topo);

        country.enter().insert("path")
            .attr("class", "country")
            .attr("d", path)
            .attr("id", function (d, i) {
                return d.id;
            })
            .attr("title", function (d, i) {
                return d.properties.name;
            })
            .style("fill", function (d, i) {
                return d.properties.color;
            })
            .on("mouseover", handleMouseOver)
            .on("mouseout", handleMouseOut);


    }

    function drawPoints() {
        d3.csv("data/sipri-report-explosions.csv", function (err, explosions) {
            explosions.forEach(function (i) {
                addpoint(i.longitude, i.latitude, i.country);
            });

        });
    }


    function redraw() {
        width = c.offsetWidth;
        height = width / 3 * 2;
        d3.selectAll('svg').remove();
        setup(width, height);
        draw(topo);
    }


    function move() {

        //var t = d3.event.translate;
        var t = [d3.event.transform.x, d3.event.transform.y];
        //var s = d3.event.scale;
        var s = d3.event.transform.k;
        zscale = s;
        var h = height / 4;

        t[0] = Math.min(
            (width / height) * (s - 1),
            Math.max(width * (1 - s), t[0])
        );

        t[1] = Math.min(
            h * (s - 1) + h * s,
            Math.max(height * (1 - s) - h * s, t[1])
        );

        //zoom.translateBy(t);
        g.attr("transform", "translate(" + t + ")scale(" + s + ")");

        //adjust the country hover stroke width based on zoom level
        d3.selectAll(".country").style("stroke-width", 1.5 / s);

    }

    var throttleTimer;

    function throttle() {
        window.clearTimeout(throttleTimer);
        throttleTimer = window.setTimeout(function () {
            redraw();
        }, 1);
    }


    //geo translation on mouse click in map
    function click() {
        var latlon = projection.invert(d3.mouse(this));
        console.log(latlon);
    }


    //function to add points and text to the map (used in plotting capitals)
    function addpoint(lon, lat, text) {

        var gpoint = g.append("g").attr("class", "gpoint");
        var x = projection([lon, lat])[0];
        var y = projection([lon, lat])[1];

        gpoint.append("svg:circle")
            .attr("cx", x)
            .attr("cy", y)
            .attr("class", "point")
            .attr("r", 1.5);

        //conditional in case a point has no associated text
        if (text.length > 0) {

            gpoint.append("text")
                .attr("x", x + 2)
                .attr("y", y + 2)
                .attr("class", "text")
                .text(text);
        }

    }

    const row = d => {
        //const netUsersWithCommas = d['Internet Users 31 Mar 2017'];
        return {
            year: +d['year'],
            country: d['country']
        };
    };

    d3.csv("data/sipri-report-explosions.csv", row, preprocessing);

    function preprocessing(data) {
        const nested = d3.nest()
            .key(function (d) {
                return d['year']
            })
            //            .rollup(function (d) {
            //                return d.length
            //            })
            .entries(data);

        const count = {};

        for (let i = 1945; i <= 1998; i++) {
            count[i] = 0;
        }

        for (let i = 0; i < nested.length; i++) {
            count[nested[i].key] = nested[i].values.length;
        }

        const processed = [];
        for (let i = 1945; i <= 1998; i++) {
            processed.push({year: String(i), value: count[i]})
        }
        console.log(count);
        console.log(d3.map(count));
        console.log(processed);
//        const processed = d3.map(count);
        drawBar(processed);
        drawPoints();
    }

    function drawBar(data) {

        console.log(data);

        const yAxisG = g2.append("g")
            .attr("class", "axis axis--y")
            .call(yAxis);

        yAxisG.append('text')
            .attr('class', 'axis-label')
            .attr('x', -innerHeight / 2)
            .attr('y', -50)
            .attr('transform', `rotate(-90)`)
            .style('text-anchor', 'middle');

        const xAxisG = g2.append("g")
            .attr("class", "axis axis--x")
            .attr("transform", "translate(0," + innerHeight + ")")
            .call(xAxis);

        const xValue = function (data) {
            return data.year;
        };
        const yValue = function (data) {
            return data.value;
        };

        xScale.range([0, innerWidth])
            .domain(data.map(function (data) {
                return data.year
            }));
        yScale.range([innerHeight, 0])
            .domain([0, 178]);

        barChart.append('g')
            .attr('class', 'brush')
            .call(brush);
//            .call(brush.move(), yScale.range());

        const bar = g2.selectAll('rect').data(data);

        bar.enter().append('rect')
            .attr('width', data => xScale.bandwidth())
    .attr('fill', 'steelblue')
            .merge(bar)
            .attr('x', function (data) {
                return xScale(xValue(data))
            })
            .attr('y', function (data) {
                return yScale(yValue(data))
            })
            .attr('height', data => innerHeight - yScale(yValue(data)));

        bar.exit().remove();

        yAxisG.call(yAxis);
        xAxisG.call(xAxis)
    }

    function brushed() {
        if (d3.event.sourceEvent && d3.event.sourceEvent.type === "zoom") return; // ignore brush-by-zoom
        var s = d3.event.selection || xScale.range();
        console.log(s);
//        console.log(s.map(x2.invert, x2));
//        console.log(s.map(x2.invert));
//        console.log(s.map(yScale.invert));
//        x.domain(s.map(xScale.invert, x2));
//        focus.selectAll(".line_casual").attr("d", lineCasual);
//        focus.select(".line_registered").attr("d", lineRegistered);
//        focus.select(".line_temp").attr("d", lineTemp);
//        focus.select(".axis--x").call(xAxis);
//        svg.select(".zoom").call(zoom.transform, d3.zoomIdentity
//            .scale(width / (s[1] - s[0]))
//            .translate(-s[0], 0));
    }
</script>
</body>
</html>